# Day 23: Fixing Committed Version History Part 5 (rebase 2)

In the previous article, we discussed that Rebase is used to "re-specify the base version" for two existing branches. After executing Rebase, it also changes the starting point of the original branch (the branch point is moved), causing changes in the version graph. However, Rebase can do more than just this - it can also be used to modify the version information of any version on a specific branch line.

This article continues our exploration of `git rebase`, diving deeper into advanced techniques and practical workflows for using rebase effectively, including modifying commit information on a branch.

## Advanced Interactive Rebase Techniques

### Splitting a Commit

To split one commit into multiple:

```
git rebase -i HEAD~3

# Mark the commit to split with "edit"
# When Git stops at that commit:
git reset HEAD^
git add file1
git commit -m "First part"
git add file2
git commit -m "Second part"
git rebase --continue
```

### Combining and Reordering

You can both reorder and combine commits in one operation:

```
git rebase -i HEAD~5

# In the editor:
pick abc123 Feature A
squash def456 Fix for A
pick jkl012 Feature C  # Moved before B
pick ghi789 Feature B  # Moved after C
fixup mno345 Typo fix for B
```

## Rebase with Exec

Run a command after each commit during rebase:

```
git rebase -i --exec "npm test" HEAD~5
```

This runs `npm test` after applying each commit, helping you find which commit broke tests.

## Rebase onto Specific Commit

Instead of a branch name, you can rebase onto a specific commit:

```
git rebase --onto <new-base-commit> <old-base-commit> <branch>
```

Example use case - removing commits from the middle of history:

```
# Remove commits between B and D
#     A---B---C---D---E feature
# Becomes:
#     A---B---D'---E' feature

git rebase --onto B D feature
```

## Rebase with Strategy Options

Use merge strategies during rebase:

```
# Always prefer our version in conflicts
git rebase -X ours main

# Always prefer their version
git rebase -X theirs main
```

## Preserving Merge Commits

By default, rebase flattens merge commits. To preserve them:

```
git rebase -p main
# or
git rebase --preserve-merges main
```

Note: `-p` is deprecated; use `--rebase-merges` instead:

```
git rebase --rebase-merges main
```

## Rebase with Fork-Point

Automatically find the fork point:

```
git rebase --fork-point main
```

This is useful when the remote branch has been force-pushed.

## Workflow: Keeping Feature Branch Updated

Common workflow to keep your feature branch up to date with main:

```
# On feature branch
git fetch origin
git rebase origin/main

# Or in one command
git pull --rebase origin main
```

## Workflow: Preparing for Pull Request

Clean up your commits before creating a pull request:

```
# 1. Interactive rebase to clean history
git rebase -i main

# 2. Squash fixup commits, reword messages
# 3. Force push to update your branch
git push -f origin feature-branch
```

## Workflow: Updating After Code Review

After code review feedback:

```
# Make changes
git add .
git commit --fixup <original-commit>

# Rebase with autosquash
git rebase -i --autosquash main

# Force push the updated branch
git push -f origin feature-branch
```

## Dealing with Force Push

When someone force-pushes a branch you're working on:

```
# Fetch the updated branch
git fetch origin

# Rebase your work onto the new history
git rebase --onto origin/feature-branch old-commit feature-branch
```

Or simply:

```
git pull --rebase origin feature-branch
```

## Rebase vs Reset for Cleanup

For cleaning up local commits before push:

**Rebase** (recommended):
* Preserves chronological order
* Interactive control
* Can cherry-pick commits

**Reset** (simpler but less flexible):
* Removes commits completely
* Restarts from clean state
* Less control over individual commits

## Common Rebase Patterns

### Pattern 1: Squash All Commits

```
git rebase -i --root
# Mark all but first commit as "squash"
```

### Pattern 2: Reword All Commit Messages

```
git rebase -i HEAD~10
# Mark all commits as "reword"
```

### Pattern 3: Remove Specific Commits

```
git rebase -i HEAD~10
# Mark unwanted commits as "drop"
```

## Rebase Safety Checklist

Before rebasing:

- [ ] Is this commit pushed to a shared branch?
- [ ] Have others based work on this commit?
- [ ] Do I have a backup (branch or tag)?
- [ ] Have I communicated with the team?
- [ ] Am I prepared to force-push?

## Recovering from Rebase Disasters

If things go wrong:

```
# Step 1: Stay calm
# Step 2: Find the old state
git reflog

# Step 3: Reset to before the rebase
git reset --hard HEAD@{5}

# Step 4: Try again more carefully
```

## Rebase and Continuous Integration

When using CI/CD with rebasing:

1. **Rebase locally** before pushing
2. **Run tests** after rebase
3. **Force push** only your branch
4. **Wait for CI** before merging
5. **Never rebase** after merge

## Best Practices Summary

1. **Local only**: Rebase only unpushed commits
2. **Small rebases**: Rebase frequently to avoid large conflicts
3. **Test thoroughly**: Run tests after rebasing
4. **Communicate**: Warn team before force-pushing
5. **Backup**: Create a backup branch before major rebases
6. **Be careful with -f**: Double-check before force-pushing

## Today's Summary

Advanced rebase techniques give you powerful tools for maintaining clean, understandable commit history. While these features can significantly improve your workflow, they require practice and careful use. The key is knowing when to use rebase and when to stick with safer alternatives like merge.

Let me reorganize the Git commands and parameters learned today:

* git rebase --exec
* git rebase --onto
* git rebase -X
* git rebase --preserve-merges
* git rebase --rebase-merges
* git rebase --fork-point
* git rebase --root
* git pull --rebase
* git push -f

---

* [Back to Table of Contents](README.md)
* [Previous Day: Fixing Committed Version History Part 4 (rebase)](22.md)
* [Next Day: Using GitHub Remote Repository - Getting Started](24.md)

---
