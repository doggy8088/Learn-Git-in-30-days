# Day 16: Using git reflog to Track Change History

Learning Git version control commands is not difficult, but understanding what Git actually does to your repository can be quite challenging. As you gradually understand Git's core concepts and operating principles, you can effectively control version changes in your Git repository. This article explains how Git records the change history for every version.

## Understanding git reflog

`git reflog` (reference log) is a mechanism that records when the tips of branches and other references were updated in the local repository. Before you fully understand Git's basic principles and object structure, you cannot truly understand the version recording process. When you don't understand the version recording process, you naturally worry "where did my version go?" You may have heard someone say "We use version control, so all versions are preserved, feel free to modify the code." Knowing this is one thing, knowing how to do it is another, and whether you can actually do it is yet another matter.

Fortunately, Git has a rigorous logging mechanism, and this mechanism is very open - the log files are all in text format and quite easy to understand. Let's explain this version recording process.

The reflog is particularly useful for:

* Finding commits that are no longer reachable from any branch
* Recovering from mistaken resets or rebases
* Understanding what you did in your repository
* Undoing accidental changes

## The logs Directory

If you enter any Git working directory's `.git/` folder, you can see a `logs` directory. This `logs` folder contains a `HEAD` file that records the version change history of the "current branch."

The file content looks like this (object IDs abbreviated for readability):

```
0000000 f5685e0 Will <xxxx@gmail.com> 1381718394 +0800	commit (initial): Initial commit
f5685e0 38d924f Will <xxxx@gmail.com> 1381718395 +0800	commit: a.txt: set 1 as content
38d924f efa1e0c Will <xxxx@gmail.com> 1381734238 +0800	commit: test
efa1e0c af493e5 Will <xxxx@gmail.com> 1381837967 +0800	commit: Add c.txt
```

## Basic Usage

To view the reflog:

```
git reflog
```

This shows a list of recent actions in reverse chronological order. From the text file, you can see the "first version" at the top, but through `git reflog`, the "latest version" is displayed first, and the "first version" last.

Each entry shows:
* The commit hash
* The reference (usually HEAD)
* The action that was performed
* The commit message

## Reflog Format

The output looks like:

```
a1b2c3d HEAD@{0}: commit: Add new feature
e4f5g6h HEAD@{1}: checkout: moving from master to feature-branch
i7j8k9l HEAD@{2}: reset: moving to HEAD~1
```

The `HEAD@{n}` notation refers to the nth prior value of HEAD. Here, each version in the history log has a number representing the position of this version in the log file. `HEAD@{0}` always represents the "latest version" of the current branch, in other words, the most recent Git operation you performed on this "branch." Any version changes you make to Git will be completely recorded.

## Recovering from Accidental Changes

When beginners first use Git, they may accidentally execute incorrect commands, such as conflicts occurring during `git merge`, or mistakes happening when executing `git pull` to get the latest version from the remote repository. In such situations, you can use the special "reference name" `HEAD@{n}` to "locate" this version and restore the current Git repository version to a previous version.

For example, if we want to "cancel" the most recent version record, we can use `git reset HEAD@{1} --hard` to restore the change. This means that the change originally at `HEAD@{0}` will be deleted. However, in Git, all changes are recorded, including your action of executing `git reset "HEAD@{1}" --hard`.

What does this mean? It means that when executing any Git command, you no longer need to worry that any of your data will be lost. No matter how wrong the command you enter, all files that are already in the repository will be preserved, with absolutely no chance of loss. So, if you want to undo the `git reset "HEAD@{1}" --hard` action you just executed, just execute `git reset "HEAD@{1}" --hard` again. Isn't that great!

## Viewing Detailed Reflog

For more detailed information:

```
git reflog show --all
```

To see the reflog for a specific branch:

```
git reflog show branch-name
```

## Using Reflog to Recover Commits

If you accidentally reset or lost commits, you can recover them using reflog:

```
# Find the commit you want to recover
git reflog

# Reset to that commit
git reset --hard HEAD@{2}
```

Or use the commit hash directly:

```
git reset --hard a1b2c3d
```

## Recovering Deleted Branches

If you deleted a branch by mistake:

```
# Find the commit where the branch was deleted
git reflog

# Recreate the branch
git branch branch-name HEAD@{3}
# or
git branch branch-name <commit-hash>
```

## Reflog Expiration

By default, reflog entries expire after 90 days for reachable commits and 30 days for unreachable commits. You can configure this:

```
git config gc.reflogExpire "90 days"
git config gc.reflogExpireUnreachable "30 days"
```

## Cleaning Up Reflog

To manually clean up reflog entries:

```
# Remove old reflog entries
git reflog expire --expire=now --all

# Run garbage collection
git gc --prune=now
```

## Limitations of Reflog

Important points to remember:

* Reflog is local only - it's not shared with others
* Reflog tracks changes to your repository, not files
* It can help you recover commits, but not uncommitted changes

## Practical Examples

### Example 1: Undoing a Hard Reset

```
# You accidentally reset
git reset --hard HEAD~3

# Find the old position
git reflog

# Restore to the old position
git reset --hard HEAD@{1}
```

### Example 2: Recovering After a Mistaken Rebase

```
# After a problematic rebase
git reflog

# Find the commit before the rebase (usually labeled "rebase finished")
git reset --hard HEAD@{5}
```

## Today's Summary

`git reflog` is a powerful safety feature that can save you from many Git mistakes. It's especially valuable when you need to recover from operations like reset, rebase, or branch deletion. While it's not a substitute for regular backups, it's an invaluable tool for local recovery.

Let me reorganize the Git commands and parameters learned today:

* git reflog
* git reflog show
* git reflog show --all
* git reset --hard HEAD@{n}
* git branch branch-name HEAD@{n}
* git reflog expire
* git gc

---

* [Back to Table of Contents](README.md)
* [Previous Day: Tags - Marking Important Events in Version Control](15.md)
* [Next Day: Basic Concepts and Usage of Merging](17.md)

---
