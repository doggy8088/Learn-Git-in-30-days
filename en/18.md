# Day 18: Fixing Committed Version History Part 1 (reset & amend)

When using Git for version control, we use `git commit` to create many versions. Since Git is a distributed version control system, compared to centralized version control systems like Subversion or TFVC, Git has less permission design for version control. Git provides more mechanisms for "modifying version records," allowing you to organize things in advance before "sharing" versions with others.

## Version Control Basic Principles

When performing version control, whether using Git, Subversion, or TFVC, maintaining good version records helps us track the update history of each version (when we need to do this). In my personal experience, we rarely have the opportunity or desire to track the software development process in a project. Many of our projects have accumulated thousands of version records - who has time to investigate that history?

However, in practice, when software bugs occur, we need to track the historical records of specific bugs to find out the real cause of the bug. This is when version control brings the greatest value.

Therefore, how to maintain good "version records" is also very important. Here are some control principles to share:

* Make a version for each small feature modification, making it easier to track changes
* Never accumulate a lot of modifications before creating a "big version"
* Fix features logically and in order, ensuring related version fixes are committed in sequence for easier tracking

However, people make mistakes - who can ensure that everyone on the team can always follow the above principles for version control? Who doesn't just "modify as they think"? Such requirements become impractical. Therefore, we need a mechanism to "modify versions" so that when versions are submitted to the remote server, they are already in a perfect state.

## Reasons for Fixing Commit History

So far, we haven't mentioned the details of "remote repositories," so most Git operations still focus on local operations, that is, version control in the working directory, with this repository located in your `.git/` directory. However, we will soon discuss the application of "remote repositories," when more than one person will have a repository, and more details will need attention.

Completely allowing everyone to arbitrarily modify commit history may sound strange to people familiar with Subversion or TFVC, because everyone used to connect centrally to a version control server, using a centralized repository. If someone could arbitrarily tamper with historical records, could it still be called version control?

Actually, in Git version control, the concept is the same. As long as the same repository is shared by multiple people, if someone arbitrarily tampers with versions, Git version control will also fail to work properly.

So, what usage scenarios would require modifying version records? You can refer to the following points.

Assuming we now have three versions [A] -> [B] -> [C]:

* You might find that version [C] was committed incorrectly and must delete all changes in this version
* You might discover after committing [C] that this version only has test code, and you want to delete it
* Some version record messages have typos, and you want to modify the message text without affecting the file change history
* You might want to adjust the commit order of these versions to [A] -> [C] -> [B] to make the version evolution more logical
* You find that version [B] forgot to include an important file before committing, and you want to remedy this change afterwards
* When you plan to "share" a branch, you discover code defects and can fix them before sharing

## Important Notes for Fixing Commit History

Git retains the mechanism for "modifying version history records," mainly hoping that after you have "self-managed versions" to a certain extent, you can organize various information in the version records yourself, so that after you "publish" the versions, others can more clearly understand what modifications you made to these versions.

Therefore, when modifying version history records, some things must be paid special attention to:

* A repository can have many branches (the default branch name is `master`)
* The minimum unit for sharing Git source code is by "branch"
* You can arbitrarily modify versions on a branch, as long as you haven't "shared" them with others
* **Once you "share" a specific branch with others, don't modify those "shared" version history records anymore!**

## Understanding git commit --amend

The `--amend` option allows you to modify the most recent commit. This is useful when you:

* Want to change the commit message
* Forgot to include some files
* Need to fix a small mistake in the last commit

### Changing the Last Commit Message

```
git commit --amend -m "New commit message"
```

### Adding Files to the Last Commit

```
# Make changes or add forgotten files
git add forgotten-file.txt

# Amend the commit
git commit --amend --no-edit
```

The `--no-edit` flag keeps the existing commit message.

### Interactive Amend

To edit the commit message in your editor:

```
git commit --amend
```

This opens your configured editor where you can modify the commit message.

## Understanding git reset

`git reset` is a powerful command that can:

* Move the current branch pointer
* Modify the staging area (index)
* Modify the working directory

There are three modes of reset:

1. **--soft**: Moves HEAD, keeps staging area and working directory unchanged
2. **--mixed** (default): Moves HEAD, resets staging area, keeps working directory unchanged
3. **--hard**: Moves HEAD, resets staging area and working directory

## Soft Reset

Moves the branch pointer but keeps your changes staged:

```
git reset --soft HEAD~1
```

This undoes the last commit but leaves your changes in the staging area, ready to be recommitted.

## Mixed Reset

Moves the branch pointer and unstages changes:

```
git reset HEAD~1
# or
git reset --mixed HEAD~1
```

This undoes the last commit and unstages the changes, but the changes remain in your working directory.

## Hard Reset

Completely discards the commit and all changes:

```
git reset --hard HEAD~1
```

**Warning**: This permanently discards changes. Use with caution!

## Resetting to a Specific Commit

You can reset to any commit:

```
# Using commit hash
git reset --hard a1b2c3d

# Using relative reference
git reset --soft HEAD~3
```

## Unstaging Files

To unstage a file without losing changes:

```
git reset HEAD file.txt
# or
git restore --staged file.txt
```

## Recovering from Reset

If you reset by mistake, you can usually recover using reflog:

```
git reflog
git reset --hard HEAD@{2}
```

## Reset vs Revert

Important distinction:

* **reset**: Rewrites history (use for local, unpushed commits)
* **revert**: Creates a new commit that undoes changes (safe for shared history)

## Common Use Cases

### Undo Last Commit, Keep Changes

```
git reset HEAD~1
```

### Undo Last Commit, Discard Changes

```
git reset --hard HEAD~1
```

### Split One Commit into Multiple

```
git reset HEAD~1
git add file1.txt
git commit -m "First part"
git add file2.txt
git commit -m "Second part"
```

### Change Last Few Commits

```
git reset --soft HEAD~3
# Make changes
git commit -m "Combined commit"
```

## Warnings and Best Practices

1. **Never reset public history**: Don't reset commits that have been pushed to shared repositories
2. **Use --amend carefully**: Only amend commits that haven't been pushed
3. **Consider alternatives**: For shared history, use `git revert` instead
4. **Check twice**: Especially before using `--hard`
5. **Know your reflog**: It can save you from mistakes

## Today's Summary

`git commit --amend` and `git reset` are powerful tools for fixing local commit history. `--amend` is perfect for quick fixes to the last commit, while `reset` gives you more control over multiple commits. However, both should be used carefully, especially for commits that have been shared with others.

Let me reorganize the Git commands and parameters learned today:

* git commit --amend
* git commit --amend --no-edit
* git reset --soft
* git reset --mixed
* git reset --hard
* git reset HEAD~n
* git reflog

---

* [Back to Table of Contents](README.md)
* [Previous Day: Basic Concepts and Usage of Merging](17.md)
* [Next Day: Setting .gitignore Ignore List](19.md)

---
