# Day 27: Version Control Through Branches in the Same Remote Repository

Different teams use different branching strategies. This article explores common branching models and when to use each one.

## Why Branching Strategies Matter

Without a clear strategy:
* Code conflicts increase
* Releases become chaotic
* Bugs slip into production
* Team coordination suffers

## GitHub Flow

**Best for**: Web applications, continuous deployment

### Strategy

* One main branch: `main`
* Feature branches for all changes
* Deploy from `main`

### Workflow

```
1. Create branch from main
   git checkout -b feature-name

2. Work and commit
   git commit -am "Add feature"

3. Push and create PR
   git push origin feature-name

4. Review and discuss

5. Deploy from branch (staging)

6. Merge to main
   # On GitHub: Merge PR

7. Deploy from main (production)
```

### Pros
* Simple and straightforward
* Fast-paced development
* Always deployable main
* Great for continuous deployment

### Cons
* No long-term release support
* Requires good CI/CD
* Not ideal for multiple versions

## Git Flow

**Best for**: Software with releases, multiple versions

### Branch Types

* **main**: Production-ready code
* **develop**: Integration branch
* **feature/**: New features
* **release/**: Release preparation
* **hotfix/**: Emergency fixes

### Workflow

```
# Start new feature
git checkout -b feature/login develop

# Work on feature
git commit -am "Implement login"

# Finish feature
git checkout develop
git merge --no-ff feature/login
git branch -d feature/login

# Start release
git checkout -b release/1.0 develop

# Prepare release (bug fixes only)
git commit -am "Bump version to 1.0"

# Finish release
git checkout main
git merge --no-ff release/1.0
git tag -a 1.0

git checkout develop
git merge --no-ff release/1.0
git branch -d release/1.0

# Hotfix
git checkout -b hotfix/1.0.1 main
git commit -am "Fix critical bug"

git checkout main
git merge --no-ff hotfix/1.0.1
git tag -a 1.0.1

git checkout develop
git merge --no-ff hotfix/1.0.1
git branch -d hotfix/1.0.1
```

### Pros
* Clear separation of concerns
* Supports multiple versions
* Structured release process

### Cons
* More complex
* Slower development cycle
* Overhead for simple projects

## GitLab Flow

**Best for**: Organizations with staging and production environments

### Strategy

* Environment branches: `main`, `staging`, `production`
* Feature branches merge to `main`
* Promotion through environments

### Workflow

```
# Feature development
git checkout -b feature-name main
# Work and commit
git push origin feature-name
# Create MR to main

# After merge to main
# Deploy to staging
git checkout staging
git merge main
git push origin staging

# After testing in staging
# Deploy to production
git checkout production
git merge staging
git push origin production
```

### Pros
* Environment-based deployment
* Clear promotion path
* Good for regulated industries

### Cons
* More branches to manage
* Requires automation
* Can be slower

## Trunk-Based Development

**Best for**: High-performing teams, continuous deployment

### Strategy

* Single trunk: `main`
* Very short-lived feature branches (< 1 day)
* Feature flags for incomplete features

### Workflow

```
# Create short-lived branch
git checkout -b quick-fix main

# Make small change
git commit -am "Fix button color"

# Merge same day
git checkout main
git merge quick-fix
git push origin main

# Or commit directly to main
# (with CI and feature flags)
```

### Pros
* Fastest integration
* Reduces merge conflicts
* Encourages CI/CD
* High code quality

### Cons
* Requires discipline
* Needs good CI/CD
* Feature flags complexity

## Release Flow (Microsoft)

**Best for**: Enterprise software, planned releases

### Strategy

* `main`: Always release-ready
* `release/*`: Stabilization branches
* Topic branches: Short-lived features

### Workflow

```
# Create topic branch
git checkout -b users/name/feature main

# Work and create PR
git push origin users/name/feature

# Create release branch
git checkout -b release/v2.0 main

# Cherry-pick into release
git cherry-pick <commit-hash>

# Release
git checkout main
git merge release/v2.0
git tag v2.0
```

### Pros
* Flexible release schedule
* Parallel development and stabilization
* Good for enterprise

### Cons
* Can be complex
* Requires cherry-picking
* More maintenance

## Choosing a Strategy

### GitHub Flow When:
* Continuous deployment
* Web applications
* Small team
* Fast iteration

### Git Flow When:
* Scheduled releases
* Desktop/mobile apps
* Need to support multiple versions
* Traditional software lifecycle

### GitLab Flow When:
* Multiple environments
* Staged deployments
* Regulatory requirements

### Trunk-Based When:
* Experienced team
* Excellent CI/CD
* Continuous deployment
* High release frequency

## Branch Naming Conventions

### Feature Branches
```
feature/user-authentication
feature/dark-mode
feat/issue-123
```

### Bug Fix Branches
```
fix/login-error
bugfix/issue-456
hotfix/critical-security-patch
```

### Release Branches
```
release/1.0
release/2.0.0
release/v1.5
```

### Other Branches
```
docs/update-readme
test/integration-tests
refactor/database-layer
chore/update-dependencies
```

## Branch Management Commands

### List Branches
```
# Local branches
git branch

# All branches (including remote)
git branch -a

# With last commit
git branch -v

# Merged branches
git branch --merged

# Unmerged branches
git branch --no-merged
```

### Delete Branches
```
# Delete local branch
git branch -d feature-name

# Force delete
git branch -D feature-name

# Delete remote branch
git push origin --delete feature-name
```

### Rename Branch
```
# Rename current branch
git branch -m new-name

# Rename other branch
git branch -m old-name new-name
```

## Today's Summary

Choosing the right branching strategy depends on your team, project, and deployment model. There's no one-size-fits-all solution. Start with a simple strategy like GitHub Flow and evolve as needed. The key is consistency and communication.

Let me reorganize the Git commands and parameters learned today:

* git checkout -b branch-name
* git merge --no-ff
* git cherry-pick
* git branch -m
* git branch --merged
* git branch --no-merged
* git push origin --delete

---

* [Back to Table of Contents](README.md)
* [Previous Day: Multiple People Working in the Same Remote Repository](26.md)
* [Next Day: Understanding GitHub Forks and Pull Request Workflow](28.md)

---
