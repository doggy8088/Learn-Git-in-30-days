# Day 22: Fixing Committed Version History Part 4 (rebase)

Rebase is one of Git's most powerful but potentially dangerous features. It allows you to rewrite commit history, making it cleaner and more linear. This article introduces the basics of `git rebase`.

## Understanding git rebase

Rebasing is the process of moving or combining a sequence of commits to a new base commit. Unlike merging, which preserves the complete history, rebasing rewrites history to create a linear progression.

## Basic Rebase

The basic rebase operation:

```
# On feature branch
git checkout feature-branch

# Rebase onto main
git rebase main
```

This replays all commits from `feature-branch` on top of `main`.

## How Rebase Works

When you rebase:

1. Git finds the common ancestor of your branch and the target branch
2. It saves all commits from your branch since that ancestor
3. It resets your branch to the target branch
4. It reapplies your saved commits one by one

## Rebase vs Merge

**Merge**:
* Preserves complete history
* Shows when branches diverged and merged
* Safe for shared branches
* Creates merge commits

**Rebase**:
* Creates linear history
* Cleaner, easier to understand
* Rewrites history (dangerous for shared branches)
* No merge commits

Visual comparison:

```
# Before rebase
     C---D feature
    /
A---B---E---F main

# After git rebase main (on feature)
             C'---D' feature
            /
A---B---E---F main

# After git merge feature (on main)
     C---D 
    /     A---B---E---F---G main
```

## Handling Conflicts During Rebase

If conflicts occur:

```
# Git pauses the rebase
# Resolve conflicts in the files
# Stage the resolved files
git add <resolved-files>

# Continue the rebase
git rebase --continue
```

To abort the rebase:

```
git rebase --abort
```

To skip the current commit:

```
git rebase --skip
```

## Interactive Rebase

Interactive rebase gives you full control over commits:

```
git rebase -i HEAD~3
```

This opens an editor where you can:

* **pick**: Keep the commit as is
* **reword**: Change the commit message
* **edit**: Stop to amend the commit
* **squash**: Combine with previous commit, keep both messages
* **fixup**: Combine with previous commit, discard this message
* **drop**: Remove the commit entirely

Example interactive rebase editor:

```
pick abc123 Add feature A
reword def456 Add feature B
squash ghi789 Fix typo in feature B
drop jkl012 Experimental change
```

## Common Interactive Rebase Tasks

### Squashing Commits

Combine multiple commits into one:

```
git rebase -i HEAD~3

# In the editor, change:
pick abc123 First commit
pick def456 Second commit
pick ghi789 Third commit

# To:
pick abc123 First commit
squash def456 Second commit
squash ghi789 Third commit
```

### Reordering Commits

Simply reorder the lines in the interactive rebase editor.

### Editing a Commit

```
git rebase -i HEAD~3

# Change "pick" to "edit" for the commit you want to modify
# Git will stop at that commit
# Make your changes
git add .
git commit --amend
git rebase --continue
```

## Rebase onto a Different Branch

```
git rebase --onto new-base old-base feature-branch
```

This moves commits from `feature-branch` that come after `old-base` onto `new-base`.

## Autosquash

Automatically squash fixup commits:

```
# Create a fixup commit
git commit --fixup <commit-to-fix>

# Later, rebase with autosquash
git rebase -i --autosquash main
```

## Golden Rule of Rebasing

**Never rebase commits that have been pushed to a shared repository!**

Rebasing rewrites history, which can cause major problems for others who have based work on those commits.

Safe for:
* Local commits not yet pushed
* Feature branches you own
* Cleaning up before creating a pull request

Dangerous for:
* Main/master branch
* Shared feature branches
* Any commits others might have based work on

## Recovering from Rebase Mistakes

If a rebase goes wrong:

```
# Find the commit before the rebase
git reflog

# Reset to that commit
git reset --hard HEAD@{2}
```

## Best Practices

1. **Rebase before push**: Clean up your local commits before sharing
2. **Don't rebase public history**: Only rebase local commits
3. **Backup before major rebase**: Create a branch first
4. **Communicate**: Let your team know if you must rebase shared code
5. **Practice**: Try rebasing on throwaway branches first

## Today's Summary

Rebasing is a powerful tool for creating clean, linear commit history. While it's excellent for local work and preparing branches for merging, it must be used carefully to avoid rewriting shared history. Understanding when and how to use rebase is essential for advanced Git workflows.

Let me reorganize the Git commands and parameters learned today:

* git rebase
* git rebase main
* git rebase -i
* git rebase --continue
* git rebase --abort
* git rebase --skip
* git rebase --onto
* git rebase --autosquash
* git commit --fixup

---

* [Back to Table of Contents](README.md)
* [Previous Day: Fixing Committed Version History Part 3 (cherry-pick)](21.md)
* [Next Day: Fixing Committed Version History Part 5 (rebase 2)](23.md)

---
