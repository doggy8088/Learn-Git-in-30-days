# Day 01: Understanding Git Version Control

I have been using Subversion (SVN) for nearly 10 years and never felt the need to switch to other version control platforms until a few years ago, when I gradually introduced TFS version control (TFS Service) in response to cloud-based changes. The transition was smooth because SVN and TFS have similar version control concepts, both being centralized version control systems. These centralized version control systems are simple, intuitive, and easy to manage permissions. To be honest, in most development scenarios, Subversion or TFS is quite sufficient. So what opportunity or requirement forced us to switch to Git version control? I believe different people have their own reasons for adopting Git - some find it fun, some find it fresh, and some find it powerful. Regardless, as long as the reason supports you to actively learn an unfamiliar technology, it's good. This article will not only introduce you to the Git version control mechanism but also share my reasons for wanting to switch to Git.

## Article Purpose

In the field of software development, version control of source code is very important. Unlike centralized version control systems such as Subversion or TFVC (Team Foundation Version Control), Git is a distributed version control system (DVCS; Distributed Version Control System) that brings many advantages to version control and solves the shortcomings of traditional centralized version control, such as support for local operations, easy backup, powerful and flexible branching and merging, and more. However, because Git version control differs greatly from traditional centralized version control tools in both version control concepts and tool usage, it creates a significant learning curve.

Although the theme of this article is "Master Git in 30 Days," to be honest, this is a bit of an overstatement because Git is vast and profound with many details to explore. If you really want to apply it to work, how many days of learning are needed to truly master it? Learning a little every day for 30 consecutive days seems like a reasonable number (or too much?). If there's a tool that everyone needs to use and needs to master immediately, and if you still don't know how to use it flexibly after 30 days of learning, then the learning curve is too high. Therefore, I think the main focus of this series of articles is "how to learn Git version control within 30 days and must be able to apply it proficiently in practical development work." This is the real purpose of this series. I won't particularly emphasize those tedious details, but there are always some important concepts and details that cannot be missed. I will try to mention some in each topic and explore them deeply when there's an opportunity. I hope everyone can learn by doing and deeply experience the powerful charm of Git version control.

## The Opportunity for Transition

In the past few months, our company had a large project with more than 12 developers participating. Everyone finally decided to adopt Git as the version control mechanism for this project. Rather than saying we adopted Git version control, the real reason for adoption was "we chose to use GitHub as our version control platform" because the GitHub platform is really well integrated, with complete Git version control support, issue tracking and management, online Wiki document management, and a friendly source code review interface. These features can effectively help us reduce team communication problems during multi-person collaborative development.

Getting started with Git was quite difficult because the concepts of Git version control are so different from Subversion that it's hard to intuitively understand the differences. Even if you're given a GUI graphical tool interface, you may not necessarily know how to use it. You know, when you have a powerful and useful tool in your hands, "using it incorrectly" is more terrible than "not knowing how to use it"! Simply put, you must first establish a mindset, understand the working principles of Git, and then start using Git-related tools (whether command-line tools or graphical interface tools). This is the right way!

## Learning Methods

When I first learned Git, I read several books (actually picked out key points), also read many online articles and presentations, and even watched several tutorial videos. By watching and learning, I could indeed learn how to use Git tools, and I didn't think it was too difficult. However, Git has many commands and parameters, completely beyond the range of brain memory. Unless you use it every day, how can you possibly type commands for version control all day long? If you have to look up a book every time you want to use a Git command, that's too inefficient. At that time, I intuitively thought that learning Git should ultimately return to useful GUI tools; otherwise, this thing may not be easy to promote in the team.

Furthermore, because Git is a "distributed version control" mechanism, when the number of developers starts to increase and each person starts to have their own copy of the repository, everyone suffers during the first multi-person branching and merging process, and it lasts for quite some time. Although there was technical sharing within the company, since everyone was learning for the first time, those abstract concepts of Git couldn't be deeply rooted in people's hearts. They could only share based on Git usage methods, such as how to use tools, what are the commonly used commands, what commands should be used in special situations, and so on. Even if complex principles were explained during the process, since everyone's understanding of Git was still vague, different people's understanding of Git version control methods was not the same, and the knowledge and concepts absorbed were not necessarily consistent. So even after the course, everyone still needed several days to continuously adapt, discuss with each other, and solve problems together. If you're the only one using Git, it's really hard to feel the benefits Git brings, and you may not be able to persist.

Therefore, I think that to learn Git version control well, it may be easier to learn if you know the following points first:

* First, have basic Git concepts. Learning through commands is the fastest way. Don't skip this part.
* Find more people to learn Git version control with you, preferably using it directly in practical development work.
* It's best to have a few advance troops in the team who can learn more Git concepts to share with others or provide timely assistance when someone gets stuck.
* Understand that Git is "distributed version control," and everyone has a complete repository, so you must merge files frequently.
* When using Git, branching and merging are normal, but whenever there's a merge, there will be conflicts. Learn how to resolve conflicts.

## Understanding Git Version Control

Git came from Linus Torvalds, the father of Linux, when he was developing the Linux kernel. Because the early version control methods were very inefficient and centralized, many problems arose when managing version control for complex and large projects like the Linux kernel. The earliest Linux kernel used BitKeeper for version control, but later Linus Torvalds designed the better Git version control system based on his experience with BitKeeper and Monotone. Originally, Git was designed only as a low-level version control tool to be used as an operational tool for other version control systems (SCM), and later gradually evolved into a complete version control system.

Interestingly, when Linus Torvalds first switched to Git for version control, Git was too complex, and many version control concepts were too different from before, which also encountered opposition from open source communities around the world. However, after years of effort and development, the tools for operating Git became more and more mature, gradually calming the opposition. According to market research in 2013, 30% of open source projects worldwide have switched to Git for version control. This is an amazing market share, meaning that Git definitely has its stunning features, and it's necessary to study it well!

Speaking of Git's architecture, it is completely based on Linus Torvalds' experience in maintaining large projects like the Linux kernel and his rich experience in file system optimization. Because of this, Git includes the following important designs:

* Strong support for non-linear development models (distributed development models)
  * Git has a fast branching and merging mechanism, including graphical tools to display the historical path of version changes.
  * Git emphasizes branching and merging very much, so in the process of version control, you will constantly perform branching and merging operations.
  * Git's branching mechanism is very lightweight, without burden. Each branch is just a reference pointer to a certain commit.
* Distributed development model
  * Everyone participating in Git development will have a complete development history.
  * When a developer first clones a Git repository, it is completely equivalent to a "complete backup" of this Git repository.
  * All changed files and historical records in the entire repository are stored in the local repository.
* Compatible with existing operating systems
  * A Git repository is actually just a folder with various related configuration files and various blob object files.
  * Git repositories can be published in any way, so you can use HTTP, FTP, rsync, SSH, or even the Git protocol as a medium for accessing Git repositories, with very high compatibility.
* Efficient handling of large projects
  * Since a complete repository will be cloned to the local machine, and the repository contains complete files and version change records, the speed of various file operations in version control will be hundreds of times faster than direct remote access.
  * This also means that Git version control will not slow down as projects become larger and files become more numerous.
* Historical record protection
  * In the Git version control process, each commit generates a hash id number, and each version in the change process refers to this hash id. As long as the hash id cannot be matched, Git will not work. So as the project grows larger and more copies of the repository are cloned, you can hardly tamper with the file content or version records.
  * **Remember: Everyone has a complete repository. If you change the original one, everyone's repository can no longer be merged back to the original repository, so you can hardly arbitrarily tamper with version records.**
* Toolkit-based design
  * Git is designed as a series of tool software (command-line tools). You can easily combine the use of different tools with great flexibility.
* Pluggable merge strategies
  * Git has a well-designed "incomplete merge" mechanism and multiple algorithms that can complete merging, and finally informs the user why automatic merging cannot be completed or notifies you that manual merging is needed.
* Passive garbage collection mechanism
  * When using Git, if you want to interrupt the current operation or restore the previous operation, it is possible. You don't have to worry about possibly using the wrong command or the command crashing halfway through execution.
  * Git's garbage collection mechanism is actually those useless files left in the file system. This garbage collection mechanism will only be automatically executed after these useless objects accumulate for a period of time, or you can also issue commands to clear them yourself. For example: git gc --prune
* Regular packing of objects
  * The "objects" we mention in Git actually represent files in the repository. In the process of version changes, the code or other files in the project will be updated. Each time it is updated, as long as the file content is different, a new "object" will be created, and all these files with different content will be retained.
  * You can imagine that as a project becomes larger and has more versions, there will be more and more objects. Although each file can be compressed individually to make the file smaller, too many files will still make file access less and less efficient. Therefore, Git's design has a mechanism that can automatically pack a group of old "objects" into a packfile to improve file access efficiency.
  * Those newly added files will still exist as single files, which also means a "file" in a Git repository is a Git "object," but it needs to be repacked every once in a while.
  * Presumably, Git will automatically perform actions such as repacking, but you can still issue commands to execute them yourself. For example: git gc
  * If you want to check whether the file system maintained by Git is complete, you can execute the following command: git fsck

Regarding Git's distributed version control system, let me reiterate a few things:

* Git can completely operate version control without server-side support because everyone has a complete copy of the repository.
* Because everyone has a complete copy of the repository, every time you commit version changes, you only commit to the local repository, so the commit speed is very fast, and you don't need a network connection, which can greatly save development time.
* Since everyone has a complete copy of the repository, this means that when using Git version control, there is no such thing as "permission control." Every member can clone the repository and can commit changes locally without any permission restrictions. When using Git, the only permission that can be set is whether you have permission to access the upstream repository or remote repository.
* If you need to exchange changed versions with others, you can do so through "merging" at any time. Git has very powerful merge tracing capabilities.
* To merge versions of multiple people, you only need to have permission or access to the shared repository.
  **For example: On the same server, you can share through folder permissions, or remotely access another server's Git repository through SSH, or share Git repositories through web servers, etc.**

## Today's Summary

Today's article is just a general introduction. If you don't quite understand Git's design philosophy, it doesn't matter. You can come back to this article after using it for a while, and you may have a deeper understanding.

I think writing "Understanding Git Version Control" is much more difficult than teaching everyone how to use it. Below I list some Git-related links for further learning.

## Reference Links

* [Git (software) - Wikipedia, the free encyclopedia](https://en.wikipedia.org/wiki/Git_(software) "Git (software) - Wikipedia, the free encyclopedia")
* [Pro Git Book](https://progit.org/)
* [Git Magic - Traditional Chinese Version](https://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_tw/)
* [Version control - Wikipedia](https://en.wikipedia.org/wiki/Version_control)

---

* [Back to Table of Contents](README.md)
* [Next Day: Three Essential Git Tools for Windows Platform](02.md)

---
