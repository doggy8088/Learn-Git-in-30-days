# Day 07: Parsing Git Data Structure - Index Structure

We know there are two important data structures in Git, namely "objects" and "index". This article is mainly used to explain the details of "index". During the process of using Git version control, you may easily understand the usage of git commands, but it's easy to fall into rote memorization and cannot use them flexibly. Even Linus Torvalds mentioned in the Mailing List: "Before users understand the meaning of the index, they cannot fully understand Git's capabilities." Therefore, understanding the purpose of "index" is very important.

## About Index

Simply put, the purpose of "index" is mainly to record "which files are about to be submitted to the next commit version".

In other words, "if you want to submit a version to the Git repository, then you must first update the index status, and the changes will be submitted."

This "index" actually has many aliases in many foreign articles, but they all mean the same thing. Don't be confused when you see related words in the future.

* Index
* Cache
* Directory cache
* Current directory cache
* Staging area
* Staged files

For example, the command `git diff --cached` is completely synonymous with `git diff --staged`.

## Commands for Operating Index

Since "index" is very important to Git, most commands have parameters related to Git index. However, we roughly list a few commands directly related to "index" for explanation.

Before explaining the commands, you can first look at the following diagram, which illustrates the lifecycle of changing states through commands. In fact, these changing processes are all processes of updating the "index file":

![image](figures/07/01.png)

First, let me introduce four file states:

* untracked (not tracked, representing the state of files that have not yet been added to the Git repository)
* unmodified (not modified, representing the state when a file is added for the first time, or the file content is consistent with HEAD content)
* modified (already modified, representing that the file has been edited, or the file content is inconsistent with HEAD content)
* staged (waiting to be committed, representing that these files will all be sent to the repository the next time git commit is executed)

### git status

Get the status of the **working tree** (working tree).

Since we have already talked about the relationship between repository, working directory, objects, and index, we can explain this relationship in one sentence:

```txt
Git repository operation is to write data into Git objects by updating the index with changes in the working directory.
```

The purpose of the `git status` command here is to display the difference between **the latest version** and **the index file**. The differences here include some subtle relationships. Let's use an example to explain this relationship.

The following is the result of executing git status:

```sh
G:\git-demo>git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#       new file:   c.txt
#
# Changes not staged for commit:
#   (use "git add <file>..." to update what will be committed)
#   (use "git checkout -- <file>..." to discard changes in working directory)
#
#       modified:   a.txt
#
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#
#       b.txt
```

Here you will see three different groups, namely:

* Changes to be committed (changes ready to be submitted)
  * There is a `new file: c.txt` file in this area, which means c.txt is a new file and has been marked as ready to commit.
  * This represents several things:
    1. The c.txt file currently exists in the **working directory**
    2. The c.txt file has been added to the **index**
    3. The content of c.txt in the **index** is consistent with the content in the **working directory**
    4. When executing git commit, the content in the **index** will be committed (not the content in the working directory)

* Changes not staged for commit (changes that have been modified but not yet staged for commit)
  * There is a `modified: a.txt` file in this area, which means a.txt is a modified file but has not been marked as ready to commit.
  * This represents several things:
    1. The a.txt file currently exists in the **working directory**
    2. The a.txt file has been added to the **index**
    3. The content of a.txt in the **index** is inconsistent with the content in the **working directory**
    4. When executing git commit, only the content in the **index** will be committed (not the content in the working directory)

* Untracked files (untracked files)
  * There is a `b.txt` file in this area, which means b.txt is a new file and has not been added to the index.
  * This represents several things:
    1. The b.txt file currently exists in the **working directory**
    2. The b.txt file has not been added to the **index**
    3. When executing git commit, this file will not be committed

### git add

Add file content to the index (stage files for the next commit).

The `git add` command has many uses. Simply put, executing this command will "update the index", but the way the index is updated may vary depending on the current file state:

* If the file is in the **untracked** state, executing `git add` will add the file content to the index
* If the file is in the **modified** state, executing `git add` will update the file content to the index
* If the file is in the **staged** state, executing `git add` will update the file content to the index again

### git rm

Remove files from the working tree and from the index.

This command will delete files from both the **working directory** and **index**. After deletion, you need to execute git commit to complete this delete action.

### git mv

Move or rename a file, a directory, or a symlink.

This command will move or rename files in both the **working directory** and **index**. After moving or renaming, you need to execute git commit to complete this action.

### git commit

Record changes to the repository.

This command will write the current **index** content into the **object database** and generate a commit object.

### git ls-files

Show information about files in the index and the working tree.

This command can display the file list and status in the index. This is a very useful command that can help you understand the current state of the index.

Some common parameters:

* `git ls-files -s` or `git ls-files --stage` : Display file list and detailed information in the index
* `git ls-files -c` or `git ls-files --cached` : Display cached file list
* `git ls-files -d` or `git ls-files --deleted` : Display deleted file list
* `git ls-files -m` or `git ls-files --modified` : Display modified file list
* `git ls-files -o` or `git ls-files --others` : Display untracked file list

## Today's Summary

"Index" in Git is a very important concept. Through the index, Git can know which files are about to be submitted to the next commit version. Through various commands, we can update the index status and control which files will be submitted. Understanding the index can help you better master Git version control.

## Reference Links

* [Git Internals - Git Objects](https://git-scm.com/book/en/Git-Internals-Git-Objects)
* [Pro Git Book](https://progit.org/)

---

* [Back to Table of Contents](README.md)
* [Previous Day: Parsing Git Data Structure - Object Structure](06.md)
* [Next Day: Basic Concepts and Usage of Branches](08.md)

---
