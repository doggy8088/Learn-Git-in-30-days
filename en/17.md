# Day 17: Basic Concepts and Usage of Merging

As mentioned in Day 08 (Basic Concepts and Usage of Branches), we learned about "branches." Now we'll discuss how to perform "merging." Since Git is a distributed version control system (DVCS), you will constantly perform branching and merging operations, whether intentional merging (`git merge`) or unintentional merging (`git pull`). In short, "branching" and "merging" operations indeed occur frequently when using Git for version control. This article will explain the basic concepts and usage of "merging" operations.

## Understanding Merging Concepts

When you create branches in a Git working directory, you can develop your system according to different needs separately without affecting each other. For example, you can keep your originally stable system in the `master` branch for development, and when you need to fix errors, create an additional `bugfix` branch to correct software errors. After the bugs are fixed, you can re-apply the changes from the `bugfix` branch to `master` through "merging." This is one of the main usage scenarios.

Generally, everyone develops on a main or default branch (`master`), then creates branches according to needs (`bugfix`), and finally merges the two branches into one. In fact, when performing a "merge" operation, you merge another branch into the current branch, and then manually remove the other branch. This matches the concept of "merging two branches into one."

In practice, there are often opportunities to merge three, four, or more branches into one of them. For example, in addition to the main branch (`master`), you also create a branch for debugging (`bugfix`) and a branch for adding features (`feature`). After developing to a certain extent, you can decide whether to merge both of these branches back into the main branch (`master`) together.

When using merging in Git, there is an important concept: **the merge action must occur within the same repository**. Recall that in any Git repository, there must be an Initial Commit object (initial version), and all other versions will be related to this version. We call this relationship "the tracked object on the branch heads," so you cannot merge a specific branch from one repository into a branch of another completely unrelated repository.

When merging, if the two branches have modified the same file, but as long as the modified lines are different, Git will automatically apply/merge these two changes for you. But if it happens that you modified "the same file" at "the same line" in both branches, a conflict event will occur during merging. When a merge conflict occurs, Git will not decide anything for you, but will hand over the work of "resolving the conflict" to "you," and these conflicting files will all be marked with an `unmerged` status. After a merge conflict, you can use the `git status` command to see these statuses.

## Types of Merges

There are two main types of merges in Git:

1. **Fast-forward merge**: Used when the target branch hasn't diverged from the source branch
2. **Three-way merge**: Used when both branches have new commits

## Fast-Forward Merge

A fast-forward merge occurs when the current branch hasn't diverged from the branch being merged. Git simply moves the branch pointer forward.

```
# On master branch
git merge feature-branch
```

If `master` hasn't had any new commits since `feature-branch` was created, Git performs a fast-forward merge.

## Three-Way Merge

When both branches have new commits, Git performs a three-way merge, creating a new merge commit that combines the changes from both branches.

```
# On master branch
git merge feature-branch
```

This creates a new commit with two parent commits.

## Preventing Fast-Forward

Sometimes you want to preserve the branch history even when a fast-forward is possible:

```
git merge --no-ff feature-branch
```

This always creates a merge commit, even for fast-forward merges.

## Merge Conflicts

Conflicts occur when the same lines in the same files have been changed differently in the two branches being merged. When this happens:

1. Git pauses the merge
2. Marks the conflicting files
3. Adds conflict markers to the files
4. Waits for you to resolve the conflicts

## Viewing Conflicting Files

To see which files have conflicts:

```
git status
```

Files with conflicts are listed as "both modified".

## Conflict Markers

Git adds markers to conflicting files:

```
<<<<<<< HEAD
Your changes
=======
Their changes
>>>>>>> branch-name
```

* `<<<<<<< HEAD`: Marks the beginning of your changes
* `=======`: Separates the two versions
* `>>>>>>> branch-name`: Marks the end of the incoming changes

## Resolving Conflicts

To resolve conflicts:

1. Open the conflicting files
2. Look for the conflict markers
3. Edit the file to resolve the conflict
4. Remove the conflict markers
5. Stage the resolved files: `git add <file>`
6. Complete the merge: `git commit`

## Aborting a Merge

If you want to cancel a merge in progress:

```
git merge --abort
```

This returns your repository to the state before the merge started.

## Viewing Merge History

To see merge commits in your history:

```
git log --oneline --graph --all
```

This shows a visual representation of your branch and merge history.

## Merge Strategies

Git supports different merge strategies:

* **recursive** (default): The default three-way merge strategy
* **ours**: Always prefer our version in conflicts
* **theirs**: Always prefer their version in conflicts

```
git merge -X ours branch-name
git merge -X theirs branch-name
```

## Best Practices

1. **Commit your work** before merging
2. **Pull latest changes** from the remote before merging
3. **Test the merge** before pushing to shared branches
4. **Communicate** with your team about merges
5. **Keep merges small** when possible

## Today's Summary

Merging is a fundamental Git operation that allows you to combine work from different branches. Understanding how merges work, especially how to handle conflicts, is essential for effective collaboration. Practice merging regularly to become comfortable with the process.

Let me reorganize the Git commands and parameters learned today:

* git merge
* git merge --no-ff
* git merge --abort
* git merge -X ours
* git merge -X theirs
* git log --graph
* git status

---

* [Back to Table of Contents](README.md)
* [Previous Day: Using git reflog to Track Change History](16.md)
* [Next Day: Fixing Committed Version History Part 1 (reset & amend)](18.md)

---
