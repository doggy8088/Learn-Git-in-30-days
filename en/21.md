# Day 21: Fixing Committed Version History Part 3 (cherry-pick)

Sometimes you want to apply specific commits from one branch to another without merging the entire branch. Git's `cherry-pick` command allows you to do exactly that - selectively pick commits and apply them to your current branch.

## Understanding git cherry-pick

`git cherry-pick` applies the changes introduced by existing commits to your current branch. It creates new commits with the same changes but different commit hashes.

## Basic Cherry-Pick

To cherry-pick a single commit:

```
# Switch to the target branch
git checkout main

# Cherry-pick the commit
git cherry-pick <commit-hash>
```

This creates a new commit on the current branch with the same changes as the specified commit.

## Cherry-Picking Multiple Commits

To cherry-pick multiple commits:

```
# Cherry-pick several commits
git cherry-pick <hash1> <hash2> <hash3>
```

To cherry-pick a range of commits:

```
# Cherry-pick commits from commit1 to commit2 (exclusive of commit1)
git cherry-pick commit1..commit2

# Cherry-pick commits from commit1 to commit2 (inclusive of commit1)
git cherry-pick commit1^..commit2
```

## Cherry-Pick Without Committing

To apply the changes without automatically creating a commit:

```
git cherry-pick --no-commit <commit-hash>
# or
git cherry-pick -n <commit-hash>
```

This is useful when you want to cherry-pick multiple commits and create a single commit.

## Handling Conflicts

If conflicts occur during cherry-pick:

```
# Resolve conflicts in the files
# Stage the resolved files
git add <resolved-files>

# Continue the cherry-pick
git cherry-pick --continue
```

To abort a cherry-pick in progress:

```
git cherry-pick --abort
```

To skip the current commit and continue with the next:

```
git cherry-pick --skip
```

## Cherry-Pick with Edit

To edit the commit message while cherry-picking:

```
git cherry-pick -e <commit-hash>
# or
git cherry-pick --edit <commit-hash>
```

## Cherry-Pick and Sign-off

To add a sign-off line to the commit message:

```
git cherry-pick -s <commit-hash>
# or
git cherry-pick --signoff <commit-hash>
```

## Practical Use Cases

### Use Case 1: Apply Hotfix to Multiple Branches

```
# Fix created on main branch (commit abc123)
git checkout release-1.0
git cherry-pick abc123

git checkout release-2.0
git cherry-pick abc123
```

### Use Case 2: Selective Feature Integration

```
# Feature branch has commits A, B, C, D
# You only want B and C on main

git checkout main
git cherry-pick <hash-B> <hash-C>
```

### Use Case 3: Recovering Lost Commits

```
# Find the lost commit using reflog
git reflog

# Cherry-pick it to current branch
git cherry-pick <lost-commit-hash>
```

## Cherry-Pick vs Merge vs Rebase

**Cherry-pick**:
* Selectively applies specific commits
* Creates new commit hashes
* Good for selective integration

**Merge**:
* Combines entire branches
* Preserves complete history
* Best for integrating feature branches

**Rebase**:
* Replays commits on new base
* Linear history
* Good for cleaning up history

## Best Practices

1. **Use sparingly**: Cherry-pick can make history confusing if overused
2. **Document why**: Explain why you cherry-picked in the commit message
3. **Avoid duplicates**: Don't cherry-pick commits that will later be merged
4. **Check for dependencies**: Ensure the commit doesn't depend on other commits
5. **Test after cherry-pick**: Verify the changes work in the new context

## Tracking Cherry-Picked Commits

Git can track cherry-picked commits:

```
# Cherry-pick with -x flag
git cherry-pick -x <commit-hash>
```

This adds a line to the commit message: "(cherry picked from commit ...)"

## Common Mistakes to Avoid

1. **Cherry-picking merge commits**: Usually causes problems
2. **Cherry-picking from feature to main**: Can create duplicate commits when merging
3. **Not testing**: Changes may behave differently in different branches
4. **Ignoring dependencies**: Cherry-picked commit may need other commits to work

## Today's Summary

`git cherry-pick` is a powerful tool for selectively applying commits from one branch to another. It's particularly useful for applying hotfixes to multiple release branches or selecting specific features from a development branch. However, it should be used judiciously as it can complicate history if overused.

Let me reorganize the Git commands and parameters learned today:

* git cherry-pick <commit>
* git cherry-pick <commit1> <commit2>
* git cherry-pick commit1..commit2
* git cherry-pick --no-commit
* git cherry-pick -n
* git cherry-pick --continue
* git cherry-pick --abort
* git cherry-pick --skip
* git cherry-pick -e
* git cherry-pick -x
* git cherry-pick --signoff

---

* [Back to Table of Contents](README.md)
* [Previous Day: Fixing Committed Version History Part 2 (revert)](20.md)
* [Next Day: Fixing Committed Version History Part 4 (rebase)](22.md)

---
